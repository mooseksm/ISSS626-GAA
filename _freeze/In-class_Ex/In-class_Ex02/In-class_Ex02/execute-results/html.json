{
  "hash": "8bb12af503adfafa7a1237f75fe15c9e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-class Exercise 2\"\nauthor: \"Kock Si Min\"\ndate: September 2, 2024\ndate-modified: \"last-modified\"\ntoc: true\nexecute:\n  eval: true\n  echo: true\n  freeze: true\n  warning: false\n  message: false\n---\n\n\n# In-class Exercise 2\n\n## Issues with Hands-on Ex 2\n\n### Installing and Launching R packages\n\n-   [**sf**](https://r-spatial.github.io/sf/) for importing, managing, and processing vector-based geospatial data, and\n\n-   [**spatstat**](https://spatstat.org/), which has a wide range of useful functions for point pattern analysis. In this hands-on exercise, it will be used to perform 1st- and 2nd-order spatial point patterns analysis and derive kernel density estimation (KDE) layer\n\n-   [**raster**](https://cran.r-project.org/web/packages/raster/) which reads, writes, manipulates, analyses and model of gridded spatial data (i.e.Â raster). In this hands-on exercise, it will be used to convert image output generate by spatstat into raster format.\n\n-   [**maptools**](https://cran.r-project.org/web/packages/maptools/index.html) which provides a set of tools for manipulating geographic data. In this hands-on exercise, we mainly use it to convert *Spatial* objects into *ppp* format of **spatstat**.\n\n-   [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html) which provides functions for plotting cartographic quality static point patterns maps or interactive maps by using [leaflet](https://leafletjs.com/) API.\n\n-   [**tidyverse**](https://www.tidyverse.org/) for performing data science tasks such as importing, wrangling and visualising data.\n\nThe packages are loaded with the following code chunk:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf,spatstat,raster,tmap,tidyverse)\n```\n:::\n\n\n### Issue 1: Defunct maptools package\n\n::: callout-tip\n**maptools** is [retired](https://cran.r-project.org/src/contrib/Archive/maptools/) and binary is removed from CRAN, however it can be downloaded from [Posit Public Package Manager](https://posit.co/products/cloud/public-package-manager/) (this site is useful for Shiny) snapshots by using the code chunk below. Alternatively, can utilise the CRAN retired website and key in the latest version.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"maptools\",\n                 repos = \"https://packagemanager.posit.co/cran/2023-10-13\")\n```\n:::\n\n:::\n\n::: callout-tip\nutilise #\\| eval: false after installing the packages to avoid the code from re-running everything the page is rendered\n:::\n\n### Issue 2\n\n-   [sf](https://r-spatial.github.io/sf/index.html) is a full programmable GIS software - does all the GIS work\n\n#### Working with *st_union()* to manipulate spatial data\n\n-   The code chunk below *st_union()* is used to derive the coastal outline of sf tibble data.frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsg_sf <- mpsz_sf %>%\n  st_union()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(sg_sf)\n```\n:::\n\n\n### Introducing spatstat\n\nspatstat has several sub-packages, the notable ones:\n\n-   [**spatstat.geom**](https://cran.r-project.org/web/packages/spatstat.geom/spatstat.geom.pdf)**:** if its sp object - use ppp or owin, if its sf object - use as.ppp or as.owin. Prof advised not to use sp object at all, just use sf.\n\n    > as.ppp - allow creation of point object\n    >\n    > as.owin - create the boundary\n\n### Kernel Density Estimation\n\nCode chunk shows 2 different ways to convert KDE output into grid object\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(bg =\"#E4D5C9\")\ngridded_kde_childcareSG_ad <- maptools::as.SpatialGridDataFrame.im(kde_childcareSG_adaptive)\nspplot(gridded_kde_childcareSG_ad)\n```\n:::\n\n\n**To use spatstat.geom method instead of maptools since the latter is now defunct:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngridded_kde_childcareSG_ad <- as(kde_childcareSG_adaptive,\n                                 \"SpatialGridDataFrame\")\nspplot(gridded_kde_childcareSG_ad)\n```\n:::\n\n\n### Monte Carlo Simulation\n\n-   to ensure reproducibility, to always set a seed before using **spatstat** functions that involve Monte Carlo simulation\n\n-   likewise, this should be applicable for other randomisation processes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n\n### Edge correction methods of spatstat\n\n-   Edge correction help to avoid biases that arise when estimating spatial statistics near the boundaries of a study area\n\n-   important when extracting spatial area cause there might be data points close to the edge, for instance:\n\n    ![](images/clipboard-438778330.png){width=\"551\"}\n\n-   For beginners, to test out the different methods for edge correction\n\n-   However, there is always the option of not carrying out edge correction if points are not near the edge as this process would take up computation time\n\n### Handling duplicated points\n\n-   Multiple points can overplot each other i.e. HDB with the same postal code - calculations will not truly reflect distribution\n\n-   in hands-on exercise 2, there is no duplicate results hence the steps are actually redundant but is for learning purposes\n\n### Section 1.5.4 of Hands-on Exercise 2\n\nFor section 1.5.4, to increase nsim as the code chunk only shows 1 time.\n\n![](images/clipboard-1659160607.png)\n\n### Section 1.5.4 of Hands-on Exercise 2\n\nsf_geometry\n\n### Section 1.7.5 of Hands-on Exercise 2\n\nsp_geometry to remove the attribute\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}