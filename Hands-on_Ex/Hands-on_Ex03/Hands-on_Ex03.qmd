---
title: "Hands-on Exercise 3"
author: "Kock Si Min"
date: September 7, 2024
date-modified: "last-modified"
toc: true
execute:
  eval: true
  echo: true
  freeze: true
  warning: false
  message: false
---

# Network Constrained Spatial Point Patterns Analysis

## 3.1 Overview

**Network constrained Spatial Point Patterns Analysis (NetSPAA)** is a collection of spatial point patterns analysis methods specially developed for analysing spatial point events that occur on or alongside a network. The spatial point event can be locations of traffic accidents or childcare centres for example. The network, on the other hand, can be a road network or a river network.

In this hands-on exercise, I will use appropriate functions of the **spNetwork** package to:

-   derive **network kernel density estimation (NKDE)** and

-   perform network G-function and K-function analysis

## 3.2 The Data

In this study, the spatial distribution of childcare centres in the Punggol Planning Area will be analysed. For this study, two geospatial datasets will be used:

-   *Punggol_St*, a line features geospatial data which stores the road network within the Punggol Planning Area

-   *Punggol_CC*, a point features geospatial data which stores the location of childcare centres within the Punggol Planning Area

Both datasets are in the ESRI shapefile format.

## 3.3 Installing and launching the R packages

In this hands-on exercise, four R packages will be used:

-   [spNetwork](https://cran.r-project.org/web/packages/spNetwork/index.html) which provides functions to perform Spatial Point Patterns Analysis such as kernel density estimation (KDE) and K-function on network. It can also be used to build spatial matrices (\`listw' objects like in 'spdep' package) to conduct any kind of traditional spatial analysis with spatial weights based on reticular distances.

-   [sf](https://r-spatial.github.io/sf/index.html) package provides functions to manage, process and manipulate Simple Features, a formal geospatial data standard that specifies a storage and access model of spatial geometries such as points, lines and polygons.

-   [tmap](https://cran.r-project.org/web/packages/tmap/index.html) which provides functions for plotting cartographic quality static point pattern maps or interactive maps by using leaflet API

```{r}
pacman:::p_load(spNetwork,sf,tmap,tidyverse)
```

## 3.4 Data Import and Preparation

The code chunk below uses `st_read()` of **sf package** to import *Punggol_St* and *Pungol_CC* geospatial datasets into RStudio as sf dataframes:

```{r}
network <- st_read(dsn="data/geospatial",
                   layer="Punggol_St")
```

```{r}
childcare <- st_read(dsn = "data/geospatial",
                     layer="Punggol_CC")
```

We can examine the structure of the simple features data tables in RStudio or use the code chunk below to print the content of the network and childcare simple features:

::: panel-tabset
## Childcare

```{r}
childcare
```

## Network

```{r}
network
```
:::

::: callout-tip
Note that **spNetwork** would require the geospatial data to contain complete CRS information.
:::

I also double check the EPSG code for both dataframes to ensure that EPSG code is correctly stated as 3414:

```{r}
st_crs(childcare)
```

```{r}
st_crs(network)
```

## 3.5 Visualising the Geospatial Data

Before going into analysis, it is always a good practice to visualise the geospatial data. There are two ways to do so.

One way is to use *plot()* of Base R as shown in the code chunk below:

```{r}
plot(st_geometry(network))
plot(childcare,add=T,col='red',pch=19)
```

A second way is to use the **mapping function of tmap package** to visualise the geospatial data with high cartographic quality and in an interactive manner:

```{r}
tmap_mode('view')
tm_shape(childcare)+
  tm_dots()+
  tm_shape(network)+
  tm_lines()
```

```{r}
tmap_mode('plot')
```

## 3.6 Network KDE (NKDE) Analysis

In this section, we will perform NKDE analysis using appropriate functions provided in the **spNetwork package**.

### 3.6.1 Preparing the lixels objects

Before computing NKDE, the Spatial Lines object needs to be cut into lixels with a specified minimal distance. This task can be performed using [lixelize_lines()](https://jeremygelb.github.io/spNetwork/reference/lixelize_lines.html) of **spNetwork**:

```{r}
lixels <- lixelize_lines(network,
                         700,
                         mindist = 350)
```

In the code above,

-   length of a lixel, *lx_length*, is set to 700m and

-   minimum length of a lixel, *mindist*, is set to 350m

After cutting, if the length of the final lixel is shorter than the minimum distance, it is added to the previous lixel. If NULL, the mindist = maxdist/10. Also note that the segments that are already shorter than the minimum distance are not modified.

::: callout-note
There is another function called *lixelize_lines.mc()* which provides multicore support.
:::

### 3.6.2 Generating line center points

Next, *lines_center()* of **spNetwork** will be used to generate a SpatialPointsDataFrame i.e. samples, with line center points as shown in the code chunk below:

```{r}
samples <- lines_center(lixels)
```

The points are located at the center of the line based on the length of the line.

### 3.6.3 Performing NKDE

```{r}
#| eval: false
densities <- nkde(network,
                  events = childcare,
                  w = rep(1, nrow(childcare)),
                  samples = samples,
                  kernel_name = "quartic",
                  bw = 300,
                  div = "bw",
                  method = "simple",
                  digits = 1,
                  tol = 1,
                  grid_shape = c(1,1),
                  max_depth = 8,
                  agg = 5,
                  sparse = TRUE,
                  verbose = FALSE)
```

Using the code above gives an error message that the number of columns of arguments do not match. Comparing both dataframes, it is noted that the *childcare* dataframe contain points that have z coordinates aka points are 3D while *network* dataframe contain points in 2D format. Based on [Details on NKDE](https://jeremygelb.github.io/spNetwork/articles/web_vignettes/NKDEdetailed.html), it seems like 2D points are required for the computation and hence an additional step of dropping the z-dimension of points in *childcare* dataframe is required. This is done using the [st_zm](https://r-spatial.github.io/sf/reference/st_zm.html)[()](https://www.rdocumentation.org/packages/sf/versions/1.0-16/topics/st_zm) function:

```{r}
childcare <- st_zm(childcare)
```

Rerunning the NKDE computation code:

```{r}
densities <- nkde(network,
                  events = childcare,
                  w = rep(1, nrow(childcare)),
                  samples = samples,
                  kernel_name = "quartic",
                  bw = 300,
                  div = "bw",
                  method = "simple",
                  digits = 1,
                  tol = 1,
                  grid_shape = c(1,1),
                  max_depth = 8,
                  agg = 5,
                  sparse = TRUE,
                  verbose = FALSE)
```

Learning lessons from the code chunk above:

-   *kernel_name* argument indicates that quartic kernel is used. Other possible kernel methods supported by **spNetwork** are triangle, gaussian, scaled gaussian, tricube, cosine, triweight, epanechnikov or uniform

-   *method* argument indicate that **simple** method is used to calculate the NKDE. At present, **spNetwork** support three popular methods:

    -   simple: this method proposes an intuitive solution. The distances between events and sampling points are replaced by network distances, and the formula of the kernel is adapted to calculate the density over a linear unit instead of an area unit.

    -   discontinuous: this method equally divides the mass density of an event at intersections of lixels.

    -   continuous: if the discontinuous method is unbiased, it leads to a discontinuous kernel function which is counter-intuitive. The continuous method divides the mass density at the intersection but adjusts the density before the intersection to make the function continuous.

#### 3.6.3.1 Visualising NKDE

Before visualising NKDE values, the code chunk below will be used to insert the computed density values i.e. densities into the *samples* and *lixel* objects as *density* field:

```{r}
samples$density <- densities
lixels$density <- densities
```

Since the SVY21 projection system is in metres, the computed density values are very small i.e. 0.0000005. The code chunk below is used to rescale the density values from the number of events per metre to number of events per kilometre, to help the mapping:

```{r}
samples$density <- samples$density*1000
lixels$density <- lixels$density*1000
```

The code below then uses appropriate functions of **tmap** package to prepare interactive and high cartographic quality map visualisation:

```{r}
tmap_mode('view')
tm_shape(lixels)+
  tm_lines(col = "density")+
tm_shape(childcare)+
  tm_dots()
```

```{r}
tmap_mode('plot')
```

## 3.7 Network Constrained G- and K-Function Analysis

In this section, complete spatial randomness (CSR) test will be performed using *kfunctions()* of **spNetwork** package. The null hypothesis is defined as such:

`H0: The observed spatial point events (i.e. distribution of childcare centres) are uniformly distributed over a street network in Punggol Planning Area.`

The CSR test is based on the assumption of the binomial point process which implies the hypothesis that the childcare centres are randomly and independently distributed over the street network.

If the hypothesis is rejected, we may infer that the distribution of the childcare centres is spatially interacting and dependent on each other and thus, may form non-random patterns.

```{r}
kfun_childcare <- kfunctions(network,
                             childcare,
                             start = 0,
                             end = 1000,
                             step = 50,
                             width = 50,
                             nsim = 49,
                             resolution = 50,
                             verbose = FALSE,
                             conf_int = 0.05)
```

Learning points from the code chunk above - there are 10 arguments used in the code chunk:

-   lines: a SpatialLinesDataFrame with the sampling points. The geometries **must be a SpatialLinesDataFrame** else it may crash if there are invalid geometries

-   points: a SpatialPointsDataFrame representing the points on the network. These points will be snapped on the network.

-   start: a double, the start value for evaluating K- and G-functions

-   end: a double, the last value for evaluating K- and G-functions

-   step: a double, the jump for evaluating the K- and G-functions

-   width: width of each donut for the G-function

-   nsim: indicates the number of Monte Carlo simulations required. Most of the time, more simulations are required for inference

-   resolution: when simulating random points on the network, selecting a resolution will greatly reduce the calculation time. When the resolution is null, the random points can occur everywhere on the graph. If a value is specified, the edges are split according to this value and the random points will be selected vertices on the new network.

-   conf_int: a double, indicating the width confidence interval (default = 0.05)

The output of *kfunctions()* is a list with the following values:

-   *plotkA:* ggplot2 object representing the values of the k-function

-   *plotgA:* ggplot2 object representing the values of the g-function

-   *valuesA:* a dataframe with the values used to build the plots

The ggplot2 object of k-function can be visualised using the code chunk below:

```{r}
kfun_childcare$plotk
```

The blue line is the empirical network K-function of the childcare centres in Punggol Planning Area. The gray envelope represents the results of the 50 simulations in the interval of 2.5% to 97.5%. As the blue line between the distances of 250m to 400m is below the gray area, we can infer that the childcare centres in Punggol Planning Area resemble regular pattern at the distance of 250m to 400m.

## 3.8 References

-   [spNetwork: Spatial Analysis on Network](https://cran.r-project.org/web/packages/spNetwork/index.html)

-   [Network Kernel Density Estimate](https://cran.r-project.org/web/packages/spNetwork/vignettes/NKDE.html)

-   [Details about NKDE](https://cran.r-project.org/web/packages/spNetwork/vignettes/NKDEdetailed.html)

-   [Network k Functions](https://cran.r-project.org/web/packages/spNetwork/vignettes/KNetworkFunctions.html)
